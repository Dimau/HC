<?php

/**
 * Класс позволяет преобразовывать (распознавать) файл формата png с номером телефона в строку с номером телефона
 *
 * Ограничения на картинку с номером телефона:
 * 1. Шрифт всегда одинаковый.
 * 2. Высота цифр одинаковая.
 * 3. Между цифрами существует пустота минимум в 2 px.
 *
 * Алгоритм распознавания выглядит так:
 * 1. Разбить все цифры между собой.
 * 2. Составить ассоциативный массив с количеством пикселей для каждой цифры.
 * 3. Посчитать для каждой цифры из капчи, из какого количества пикселей она состоит а именно сколько содержит пикселей отличных от цвета фона.
 * 4. Получить цифру из массива соответствий.
 */

class RecognizerPhoneNumber {

    private $im; // Ресурс для работы с исходным изображением (специально преобразованная картинка в формате PNG)
    private $binaryMatrix; // Бинарная матрица для исходного изображения
    private $explodedChars; // Массив, каждый элемент которого представляет собой ассоциативный массив с 2-мя параметрами: номер столбца, с которого начинается в $this->binaryMatrix символ и номер столбца, на котором этот сивол в $this->binaryMatrix заканчивается
    private $resolve; // Номер телефона в виде строки

    /* Avito
   public $assocNumber = array(
       '47' => 0,
       '18' => 1,
       '41' => 2,
       '45' => 3,
       '31' => 4,
       '37' => 5,
       //'44' => 6,
       '28' => 7,
       '59' => 8,
       '44' => 9,
       '5' => "-"
   ); */
    /* Slando */
    /* public $assocNumber = array(
        '53' => 0,
        '25' => 1,
        '40' => 2,
        '42' => 3,
        '34' => 4,
        //'40' => 5,
        '46' => 6,
        '30' => 7,
        //'53' => 8,
        '45' => 9,
        '5' => "-"
    );*/

    /**
     * КОНСТРУКТОР
     */
    public function __construct($path) {

        // Используя путь к файлу, создаем ресурс изображение для дальнейшей обработки
        if (!($this->im = @imagecreatefrompng($path))) {
            // Если не удалось получить изображение - остальные действия не имеют смысла
            return FALSE;
        }

        // Получим бинарную матрицу изображения (все пиксели, которые отличаются цветом от фона = 1, а пиксели фона = 0)
        if (!($this->binaryMatrix = $this->imageToMatrix())) {
            return FALSE;
        }

        // Получим массив, каждый элемент которого представляет собой ассоциативный массив с 2-мя параметрами: номер столбца, с которого начинается в $this->binaryMatrix символ и номер столбца, на котором этот сивол в $this->binaryMatrix заканчивается
        $this->explodedChars = $this->explodeMatrix($this->binaryMatrix);

        // Инициализируем строку с решением (после окончания работы конструктора в ней должен храниться номер телефона)
        $this->resolve = '';

        // Преобразовываем каждый символ на картинке в соответствующий строковый символ
        foreach ($this->explodedChars as $number) {
            $this->resolve .= $this->convertToChar($number);
        }

        return TRUE;
    }

    // Возвращает номер телефона в виде строки (сам номер телефона вычисляется еще при работе конструктора)
    public function getResolve() {
        return $this->resolve;
    }

    /**
     * Конвертация рисунка в бинарную матрицу
     * Все пиксели отличные от фона получают значение 1
     * @return array|bool - бинарная матрица в случае успеха и FALSE в случае неудачи
     */
    private function imageToMatrix() {

        // Размер изображения в пикселях
        $height = imagesy($this->im);
        $width = imagesx($this->im);

        // Инициализируем цвет фона. Ниже в данном методе по первому пикселю картинки по факту переопределим его
        $background = array("r" => 0, "g" => 0, "b" => 0);

        // Инициализируем матрицу для хранения бинарной матрицы картинки
        $binary = array();

        // Перебираем каждый пиксель на исходной картинке и ставим ему в соответствие 1, если он отличается от фона и 0, если по цвету совпадает с фоном
        for ($i = 0; $i < $height; $i++) for ($j = 0; $j < $width; $j++) {

            // Получаем индексы цвета RGB
            $rgb = imagecolorat($this->im, $j, $i);
            list($r, $g, $b) = array_values(imageColorsForIndex($this->im, $rgb));

            // Вычисляем фактический цвет фона изображения
            if ($i == 0 && $j == 0) {
                $background["r"] = $r;
                $background["g"] = $g;
                $background["b"] = $b;
            }

            // Если цвет пикселя не равен фоновому, заполняем матрицу единицей
            $binary[$i][$j] = ($r == $background["r"] && $g == $background["g"] && $b == $background["b"]) ? 0 : 1;
        }

        // Если не получилось - вернем FALSE
        if (count($binary) != 0) {
            return $binary;
        } else {
            return FALSE;
        }

    }

    /**
     * Метод используется для выделения отдельных символов на картинке
     * @return array возвращает массив, каждый член которого содержит параметр "start" - номер столбца картинки, с которого начинается данный символ, и параметр "end" - номер столбца картинки, на котором заканчивается данный символ
     */
    private function explodeMatrix() {

        // Временный массив, каждый элемент которого = 1, если в соответствующем столбце картинки содержится хотя бы 1 пиксель, отличающийся от фона. И элемент массива = 0, если в соответствующем столбце содержится только фон и нет ни одного пикселя от символа
        $temp = array();

        // Сложение столбцов для выявления интервалов между знаками (если в столбце нет ни одного пикселя, который бы отличался по цвету от фона, то значит это интервал между знаками)
        for ($j = 0, $sj = count($this->binaryMatrix[0]); $j < $sj; $j++) { // Внутри первого цикла перебираем номер столбца
            $sum = 0;
            for ($i = 0, $si = count($this->binaryMatrix); $i < $si; $i++) { // Внутри второго цикла перебираем номер строки
                $sum += $this->binaryMatrix[$i][$j];
            }
            $temp[] = $sum ? 1 : 0;
        }

        // Вычисление координат столбцов, с которого начинается и на котором заканчивается каждый отдельностоящий символ.
        $start = false;
        $countPart = 0;
        $arrayInterval = array();

        foreach ($temp as $k => $v) {

            // Отмечаем столбец, с которого начинается символ с номером $countPart
            if ($v == 1 && !$start) {
                $arrayInterval[$countPart]['start'] = $k;
                $start = true;
            }

            // Отмечаем столбец, на котором заканчивается символ с номером $countPart
            if ($v == 0 && $start) {
                $arrayInterval[$countPart]['end'] = $k - 1;
                $start = false;
                $countPart++;
            }
        }

        // Возвращаем массив, каждый элемент которого представляет собой ассоциативный массив с 2-мя параметрами: номер столбца, с которого начинается в $this->binaryMatrix символ и номер столбца, на котором этот сивол в $this->binaryMatrix заканчивается
        return $arrayInterval;
    }


    private function convertToChar($number) {

        // Инициализируем переменную для хранения возвращаемого символа
        $result = "";

        // С какого столбца начинается сивол на картинке и каким заканчивается
        $startCol = $number["start"];
        $endCol = $number["end"];

        // Составим массив из всех пикселей, относящихся к данному символу на картинке
        $signOfChar = array();
        for ($j = $startCol; $j <= $endCol; $j++) {
            for ($i = 0, $si = count($this->binaryMatrix); $i < $si; $i++) {
                $signOfChar[] = $this->binaryMatrix[$i][$j];
            }
        }

        // TODO: test
        //return(json_encode($signOfChar));

        if ($signOfChar == array(0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0)) {
            return 0;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0)) {
            return 1;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0)) {
            return 2;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0)) {
            return 3;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0)) {
            return 4;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,1,0,0,0,0)) {
            return 5;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0)) {
            return 6;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0)) {
            return 7;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0)) {
            return 8;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0)) {
            return 9;
        } elseif ($signOfChar == array(0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0)) {
            return "-";
        }

        // Если совпадений не обнаружили, то вернем пустоту
        return "";
    }

    // TODO: test
    /**
     * Выводит матрицу на экран
     * @param type $binaryMatrix
     */
    public function printMatrix($binaryMatrix) {
        for ($i = 0; $i < count($binaryMatrix); $i++) {
            echo "<br/>";
            for ($j = 0; $j < count($binaryMatrix[0]); $j++) {
                echo $binaryMatrix[$i][$j] . " ";
            }
        }
    }

}

// TODO: test
// пробуем распознать картинку 1.png
$encrypt = new RecognizerPhoneNumber('6.png');
echo "<br><span style='font-size: 25px;'>Resolve: " . $encrypt->getResolve() . "</span><br><br>";
//$encrypt->printMatrix($encrypt->binaryMatrix);

  